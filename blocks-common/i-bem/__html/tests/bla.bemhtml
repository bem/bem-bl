!this._mode {

    true: {
        var vBlock = this.ctx.block,
            vElem = this.ctx.elem,
            block = this._currBlock || this.block;
        local(
            this._mode = 'default',
            this.block = vBlock || (vElem ? block : undefined),
            this._currBlock = vBlock || vElem ? undefined : block,
            this.elem = this.ctx.elem,
            this.mods = this.ctx.mods,
            this.elemMods = this.ctx.elemMods) this.apply();
    }

    this._.isArray(this.ctx): {
        var v = this.ctx,
            l = v.length,
            i = 0;
        while(i < l)
            local(this.ctx = v[i++]) this.apply();
    }

    !this.ctx: {}

    this._.isSimple(this.ctx): {
        this._buf.push(this.ctx)
    }

}


default: {
    var _this = this,
        BEM = _this.BEM,
        v = this.ctx,
        buf = this._buf,
        tag;

    local(this._mode = 'tag') tag = this.apply();
    tag || (tag = v.tag || 'div');

    var attrs;
    local(this._mode = 'attrs') attrs = this.apply();
    attrs = this._.extend(v.attrs, attrs);

    var jsParams, js;
    if(v.block && v.js !== false) {
        local(this._mode = 'js') js = this.apply();
        js = this._.extend(v.js, js === true? {} : js);
        js && ((jsParams = {})[v.block] = js);
    }

    buf.push('<', tag);

    var isBEM = v.block || v.elem,
        cls;

    local(this._mode = 'cls') cls = this.apply();
    cls || (cls = v.cls);

    if(isBEM || cls) {
        buf.push(' class="');
        if(isBEM) {

            BEM.INTERNAL.buildClasses(this.block, v.elem, v.elemMods || v.mods, buf);

            var mix;
            local(this._mode = 'mix') mix = this.apply();
            mix = mix? mix.concat(v.mix) : v.mix;

            mix && mix.forEach(function(mix) {
                var hasItem = mix.block || mix.elem,
                    block = mix.block || _this.block;
                hasItem && buf.push(' ');
                BEM.INTERNAL[hasItem? 'buildClasses' : 'buildModsClasses'](
                    block,
                    mix.elem,
                    mix.elemMods || mix.mods,
                    buf);
                mix.js && ((jsParams || (jsParams = {}))[block] = mix.js === true? {} : mix.js);
            });

        }

        cls && buf.push(isBEM? ' ' : '', cls);

        jsParams && buf.push(' i-bem');
        buf.push('"');
    }

    jsParams && buf.push(
        " onclick='return ",
        JSON.stringify(jsParams),
        "'");

    var attrs;
    local(this._mode = 'attrs') attrs = this.apply();
    attrs = this._.extend(attrs, v.attrs); // NOTE: возможно стоит делать массив, чтобы потом быстрее сериализовывать
    if(attrs) {
        var name; // TODO: поправить при апдейте ometa-js
        for(name in attrs)
            buf.push(' ', name, '="', attrs[name], '"'); // TODO: escaping!
    }

    if(this._.isShortTag(tag)) {
        buf.push('/>');
    } else {
        buf.push('>');

        var content;
        local(this._mode = 'content') content = this.apply();
        if(content || content === 0)
            local(
                this.ctx = content,
                this._mode = '') this.apply();

        buf.push('</', tag, '>');
    }
}

tag: undefined
attrs: undefined
cls: undefined
js: undefined
mix: undefined
content: this.ctx.content



!this._start: {
    var BEM = {},
        toString = Object.prototype.toString,
        SHORT_TAGS = { // хэш для быстрого определения, является ли тэг коротким
            area : 1, base : 1, br : 1, col : 1, command : 1, embed : 1, hr : 1, img : 1,
            input : 1, keygen : 1, link : 1, meta : 1, param : 1, source : 1, wbr : 1 };

    /** @fileOverview модуль для внутренних BEM-хелперов */
    /** @requires BEM */

    (function(BEM, undefined) {

    /**
     * Разделитель для модификаторов и их значений
     * @const
     * @type String
     */
    var MOD_DELIM = '_',

    /**
     * Разделитель между именами блока и вложенного элемента
     * @const
     * @type String
     */
        ELEM_DELIM = '__',

    /**
     * Паттерн для допустимых имен элементов и модификаторов
     * @const
     * @type String
     */
        NAME_PATTERN = '[a-zA-Z0-9-]+';

    function buildModPostfix(modName, modVal, buffer) {

        buffer.push(MOD_DELIM, modName, MOD_DELIM, modVal);

    }

    function buildBlockClass(name, modName, modVal, buffer) {

        buffer.push(name);
        modVal && buildModPostfix(modName, modVal, buffer);

    }

    function buildElemClass(block, name, modName, modVal, buffer) {

        buildBlockClass(block, undefined, undefined, buffer);
        buffer.push(ELEM_DELIM, name);
        modVal && buildModPostfix(modName, modVal, buffer);

    }

    BEM.INTERNAL = {

        NAME_PATTERN : NAME_PATTERN,

        MOD_DELIM : MOD_DELIM,
        ELEM_DELIM : ELEM_DELIM,

        buildModPostfix : function(modName, modVal, buffer) {

            var res = buffer || [];
            buildModPostfix(modName, modVal, res);
            return buffer? res : res.join('');

        },

        /**
         * Строит класс блока или элемента с учетом модификатора
         * @private
         * @param {String} block имя блока
         * @param {String} [elem] имя элемента
         * @param {String} [modName] имя модификатора
         * @param {String} [modVal] имя элемента
         * @param {Array} [buffer] буфер
         * @returns {String|Array} строка класса или буфер (в зависимости от наличия параметра buffer)
         */
        buildClass : function(block, elem, modName, modVal, buffer) {

            var typeOf = typeof modName;
            if(typeOf == 'string') {
                if(typeof modVal != 'string') {
                    buffer = modVal;
                    modVal = modName;
                    modName = elem;
                    elem = undefined;
                }
            } else if(typeOf != 'undefined') {
                buffer = modName;
                modName = undefined;
            } else if(elem && typeof elem != 'string') {
                buffer = elem;
                elem = undefined;
            }

            if(!(elem || modName || buffer)) { // оптимизация для самого простого случая
                return block;
            }

            var res = buffer || [];

            elem?
                buildElemClass(block, elem, modName, modVal, res) :
                buildBlockClass(block, modName, modVal, res);

            return buffer? res : res.join('');

        },

        /**
         * Строит классы модификаторов
         * @private
         * @param {String} block имя блока
         * @param {String} [elem] имя элемента
         * @param {Object} [mods] имя модификатора
         * @param {Array} [buffer] буфер
         * @returns {String|Array} строка класса или буфер (в зависимости от наличия параметра buffer)
         */
        buildModsClasses : function(block, elem, mods, buffer) {

            var res = buffer || [];

            if(mods) {
                var modName; // TODO: поправить при апдейте ometa-js
                for(modName in mods)
                    if(mods.hasOwnProperty(modName)) {
                        var modVal = mods[modName];
                        res.push(' ');
                        elem?
                            buildElemClass(block, elem, modName, modVal, res) :
                            buildBlockClass(block, modName, modVal, res);
                    }
            }

            return buffer? res : res.join('');

        },

        /**
         * Строит полные классы блока или элемента с учетом модификаторов
         * @private
         * @param {String} block имя блока
         * @param {String} [elem] имя элемента
         * @param {Object} [mods] имя модификатора
         * @param {Array} [buffer] буфер
         * @returns {String|Array} строка класса или буфер (в зависимости от наличия параметра buffer)
         */
        buildClasses : function(block, elem, mods, buffer) {

            var res = buffer || [];

            elem?
                buildElemClass(block, elem, undefined, undefined, res) :
                buildBlockClass(block, undefined, undefined, res);

            this.buildModsClasses(block, elem, mods, buffer);

            return buffer? res : res.join('');

        }

    };

    })(BEM);

    var ctx = {
            ctx: this,
            _start: true,
            apply: this.apply,
            _buf: [],
            _: {
                isArray: function(obj) {
                    return toString.call(obj) === "[object Array]";
                },
                isSimple: function(obj) {
                    var t = typeof obj;
                    return t === 'string' || t === 'number';
                },
                isShortTag: function(t) {
                    return SHORT_TAGS.hasOwnProperty(t);
                },
                extend: function(o1, o2) {
                    if(!o1 || !o2) return o1 || o2;
                    var res = {}, n;
                    for(n in o1) o1.hasOwnProperty(n) && (res[n] = o1[n]);
                    for(n in o2) o2.hasOwnProperty(n) && (res[n] = o2[n]);
                    return res;
                }
            },
            BEM: BEM
        };
    ctx.apply(ctx);
    return ctx._buf.join('');
}



block b-bla, tag: 'span'
block b-bla, mix: [{ mods: { m2: 'v2' } }]
block b-bla, js: true
block b-alb, attrs: { bbb: 1, title: 2 }
block b-alb, js: { bbb: 1, title: 2 }

block b-nojs, tag, !this.elem: 'table'
block b-nojs, default, !this.elem, !this.ctx._wrap: {
    local(
        this.ctx._wrap = true,
        this.ctx = { elem: 'run', content: this.ctx },
        this._mode = '') this.apply();
}

elem elem1, default: {
    local(
        this.ctx = this.ctx.content,
        this._mode = '') this.apply();
}
