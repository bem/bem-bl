ometa BEMHTMLParser <: XJSTParser {
    isKeyword = :x ?(x === 'applyCtx')
              | ^isKeyword,

    bemMatch = bemBlock | bemElem | bemMod,

    bemVal = letter:x (letter | digit | '-')+:xs -> [#string, x + xs.join('')],
    bemVal = asgnExpr,

    bemPredic :n = spaces seq(n):nn space+ -> nn,

    bemBlock = bemPredic('block'):n bemVal:v -> [#block, v],
    bemElem = bemPredic('elem') bemVal:v -> [#elem, v],
    bemMod = bemPredic('mod') bemVal:m space+ bemVal:v -> [#blockMod, m, v],
    bemMod = bemPredic('elemMod') bemVal:m space+ bemVal:v -> [#elemMod, m, v],

    bemCustom = asgnExpr:e -> [#xjst, e],

    bemhtmlSet = spaces <letter (letter | digit | '-')*>:nn
               &(spaces ('{' | ':' | ','))
               ?(!BEMHTMLParser._isPrimitive(nn))
               -> [ nn ],

    bemMatchAndSet = bemMatch | bemhtmlSet | bemCustom,
    listBemMatchAndSet %(this.predicates = [])
        = bemMatchAndSet:t ',' listBemMatchAndSet:ts -> {
          BEMHTMLParser._applyPredicates(
              this.predicates,
              BEMHTMLParser._concatChildren(t, ts));
        } | bemMatchAndSet:t spaces '{' spaces listBemMatchAndSet+:ts spaces '}' spaces -> {
          BEMHTMLParser._applyPredicates(
              this.predicates,
              BEMHTMLParser._concatChildren(t, [#sub, ts]))
        } | bemMatchAndSet:t ':' (asgnExpr:e -> [#return, e] | stmt):c ','? -> {
          BEMHTMLParser._applyPredicates(this.predicates, [t, [#body, c]])
        },

    applyMode :type = "apply" "(" expr:e ")"
        { BEMHTMLParser._transMode(e) }:modded_e
        applyFactory([type, modded_e]):r -> r,

    applyCtx :type = "applyCtx" "(" expr:ctx ")" = {
          BEMHTMLParser._transMode([
            #binop, ',',
            [#set, [#getp, [#string, 'ctx'], [#this] ], ctx],
            [#string, '']
          ])
        }:modded_e
        applyFactory([type, #next, modded_e]):r -> r,

    primExprHd = applyMode(#expr):r -> r
               | applyCtx(#expr):r -> r
               | ^primExprHd,

    stmt       = applyMode(#stmt):r -> r
               | applyCtx(#stmt):r -> r
               | ^stmt,

    topLevel = listBemMatchAndSet*:ts spaces end -> {
      BEMHTMLParser._addElemPredic(BEMHTMLParser._dropAllSubs(ts))
    }

}

BEMHTMLParser._primitives = {
  'true': true,
  'false': true,
  'null': true,
  'undefined': true,
  'NaN': true,
  'Infinity': true
};

BEMHTMLParser._isPrimitive = function(name) {
  return BEMHTMLParser._primitives[name];
};

BEMHTMLParser._transMode = function transMode(e) {
    function traverse(e) {
    if (e[0] !== 'binop' && e[1] !== ',') return [ e ];
    return [].concat(traverse(e[2]), traverse(e[3]));
  }

  return traverse(e).map(function (e) {
    if (e[0] !== 'string') return e;
    return [#set, [#getp, [#string, '_mode'], [#this]], e];
  }).reduce(function (acc, current) {
    return [#binop, ',', acc, current];
  });
};

BEMHTMLParser._applyPredicates = function(predicates, to) {
  if (predicates.length != 0) to.unshift(['xjst', predicates]);
  return to;
};

BEMHTMLParser._concatChildren = function(p, cs) {
    if(cs[0] === 'sub') {
        var res = [], i = 0, c;
        while(c = cs[1][i++]) {
            var cc = BEMHTMLParser._concatChildren(p, c);
            BEMHTMLParser._dropSub(res, cc);
        }
        return [#sub, res];
    } else return [p].concat(cs)
};

BEMHTMLParser._dropSub = function(buf, t) {
    t[0] === 'sub'?
        buf.push.apply(buf, t[1]) :
        buf.push(t);
};

BEMHTMLParser._dropAllSubs = function(ts) {
    var res = [], i = 0, t;
    while(t = ts[i++]) BEMHTMLParser._dropSub(res, t);
    return res;
};

BEMHTMLParser._addElemPredic = function(ts) {
    ts.forEach(function(t){
        var isBlock = false, isElemOrCustom = false;
        t.forEach(function(p){
            isBlock || (isBlock = p[0] === 'block');
            isElemOrCustom || (isElemOrCustom = p[0] == 'elem' || p[0] == 'xjst');
        });
        isBlock && !isElemOrCustom && t.unshift(['xjst', ['unop', '!', ['getp', ['string', 'elem'], ['this']]]]);
    });
    return ts;
};

ometa BEMHTMLToXJST <: XJSTCompiler {

    bhPredic = [#block trans:e] -> { 'this.block === (' + e + ' )'},
    bhPredic = [#blockMod trans:m trans:v] -> { 'this.mods && this.mods[' + m + '] === (' + v + ')' },
    bhPredic = [#elem trans:e] -> { 'this.elem === (' + e  + ')' },
    bhPredic = [#elemMod trans:m trans:v] -> { 'this.elemMods && this.elemMods[' + m + '] === (' + v + ')' },
    bhPredic = [#xjst trans:e] -> { '(' + e + ')' },
    bhPredic = [:m] -> { 'this._mode === "' + m + '"' },

    bhBody = [#body tBody:b] -> { '{ ' + b + ' }' },

    bhTemplate = [bhPredic+:ps bhBody:b] -> { 'template(' + ps.join(' && ') + ') ' + b },

    topLevel = [bhTemplate+:ts] -> ts.join('\n\n'),
    topLevel = bhTemplate:t -> t,
    topLevel = empty -> 'template(true){}'

}
