var ometa = require('ometajs'),
    xjst = require('xjst'),
    XJSTParser = xjst.XJSTParser,
    XJSTCompiler = xjst.XJSTCompiler;

ometa BEMHTMLParser <: XJSTParser {
  isKeyword = :x ?(x === 'applyCtx')
            | ^isKeyword,

  bemMatch = bemBlock | bemElem | bemMod,

  bemVal = letter:x (letter | digit | '-')*:xs -> [#string, x + xs.join('')],
  bemVal = asgnExpr,

  bemPredic :n = spaces seq(n):nn space+ -> nn,

  bemBlock = bemPredic('block'):n bemVal:v -> [#block, v],
  bemElem = bemPredic('elem') bemVal:v -> [#elem, v],
  bemMod = bemPredic('mod') bemVal:m space+ bemVal:v -> [#blockMod, m, v],
  bemMod = bemPredic('elemMod') bemVal:m space+ bemVal:v -> [#elemMod, m, v],

  bemCustom = asgnExpr:e -> [#xjst, e],

  bemhtmlSet = spaces <letter (letter | digit | '-')*>:nn
               &(spaces ('{' | ':' | ','))
               ?(!BEMHTMLParser._isPrimitive(nn))
               -> [ nn ],

  bemMatchAndSet = bemMatch | bemhtmlSet | bemCustom,
  listBemMatchAndSet = bemMatchAndSet:t spaces
                     ( ',' spaces listBemMatchAndSet:ts -> {
                       BEMHTMLParser._concatChildren(t, ts)
                     } | '{' spaces listBemMatchAndSet+:ts spaces '}'
                          spaces -> {
                       BEMHTMLParser._concatChildren(t, [#sub, ts])
                     } | ':' (asgnExpr:e -> [#return, e] | stmt):c ','? -> {
                       [t, [#body, c]]
                     }),

  applyMode :type = "apply" "(" expr:e ")"
      { BEMHTMLParser._transMode(e) }:modded_e
      applyFactory([type, modded_e]):r -> r,

  applyCtx :type "applyCtx" "(" expr:ctx ")" = {
        BEMHTMLParser._transMode([
          #binop, ',',
          [#set, [#getp, [#string, 'ctx'], [#this] ], ctx],
          [#string, '']
        ])
      }:modded_e
      applyFactory([type, #next, modded_e]):r -> r,

  primExprHd = applyMode(#expr):r -> r
             | applyCtx(#expr):r -> r
             | ^primExprHd,

  stmt       = applyMode(#stmt):r -> r
             | applyCtx(#stmt):r -> r
             | ^stmt,

  topLevel = listBemMatchAndSet*:ts spaces end -> {
    BEMHTMLParser._addElemPredic(BEMHTMLParser._dropAllSubs(ts))
  }
}

BEMHTMLParser._transMode = function transMode(e) {
    function traverse(e) {
    if (e[0] !== 'binop' && e[1] !== ',') return [ e ];
    return [].concat(traverse(e[2]), traverse(e[3]));
  }

  return traverse(e).map(function (e) {
    if (e[0] !== 'string') return e;
    return [#set, [#getp, [#string, '_mode'], [#this]], e];
  }).reduce(function (acc, current) {
    return [#binop, ',', acc, current];
  });
};

BEMHTMLParser._primitives = {
  'true': true,
  'false': true,
  'null': true,
  'undefined': true,
  'NaN': true,
  'Infinity': true
};

BEMHTMLParser._isPrimitive = function(name) {
  return BEMHTMLParser._primitives[name];
};

BEMHTMLParser._concatChildren = function(p, cs) {
  if (cs[0] !== 'sub') return [p].concat(cs);

  return [#sub, [].concat.apply([], cs[1].map(function(cs) {
    var cc = BEMHTMLParser._concatChildren(p, cs);
    return cc[0] === 'sub' ? cc[1] : [cc];
  }))];
};

BEMHTMLParser._dropAllSubs = function(ts) {
  return [].concat.apply([], ts.map(function(t) {
    return t[0] === 'sub' ? t[1] : [t];
  }));
};

BEMHTMLParser._addElemPredic = function(ts) {
  function isSafePredic(p) {
    switch (p[0]) {
      case 'get':
      case 'string':
      case 'number':
        return true;
      case 'getp':
        // Either this["some not elem property"],
        // or (some other host)["any property"]
        return p[2][0] === 'this' ?
            p[1][0] !== 'call' &&
            (p[1][0] !== 'string' || p[1][1] !== 'elem')
            :
            p[2][0] !== 'call';
      case 'unop':
        return isSafePredic(p[2]);
      case 'binop':
        return isSafePredic(p[2]) && isSafePredic(p[3]);
      default:
        return false;
    }
  }

  ts.forEach(function(t) {
    var isBlock,
        isNotElem;

    isBlock = t.some(function(p) {
      return p[0] === 'block';
    });

    if (!isBlock) return;

    isNotElem = t.every(function(p) {
      if (p[0] === 'elem' ||
          p[0] === 'xjst' && !isSafePredic(p[1])) {
        return false;
      }

      return true;
    });

    if (!isNotElem) return;

    t.unshift([
      'xjst',
      ['unop', '!', ['getp', ['string', 'elem'], ['this']]]
    ]);
  });
  return ts;
};

ometa BEMHTMLToXJST <: XJSTCompiler {
  bhPredic = [#block trans:e] -> { 'this.block === ' + e },
  bhPredic = [#blockMod trans:m trans:v] -> {
    'this.mods && this.mods[' + m + '] === ' + v
  },
  bhPredic = [#elem trans:e] -> { 'this.elem === ' + e },
  bhPredic = [#elemMod trans:m trans:v] -> {
    'this.elemMods && this.elemMods[' + m + '] === ' + v
  },
  bhPredic = [#xjst trans:e] -> e,
  bhPredic = [:m] -> { 'this._mode === "' + m + '"' },

  bhBody = [#body tBody:b] -> { '{ ' + b + ' }' },

  bhTemplate = [bhPredic+:ps bhBody:b] -> {
    'template(' + ps.join(' && ') + ') ' + b
  },

  topLevel = [bhTemplate+:ts] -> ts.join('\n\n'),
  topLevel = bhTemplate:t -> t,
  topLevel = empty -> 'template(true){}'
}
