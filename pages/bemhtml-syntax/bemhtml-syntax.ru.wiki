==Основные понятия шаблонизатора BEMHTML

BEMHTML — это шаблонизатор, использующий предметную область "Блок-Элемент-Модификатор". Шаблоны, написанные на BEMHTML, компилируются в plain JavaScript, который может быть выполнен в любом интерпретаторе JavaScript (как на сервере, так и в браузере).

Входными данными для таких шаблонов служит описание страницы в формате JSON, а на выходе получается HTML. Простой пример такого описания страницы находится в тестовом проекте библиотеки блоков: https://github.com/bem/bem-bl-test/blob/master/pages/example/example.bemjson.js

О том, что такое BEMHTML, расказывалось в докладе Сергея Бережного «bemhtml — bem js-шаблонизатор», можно посмотреть видео и почитать презентацию.

BEMHTML-шаблоны построены по декларативному принципу (как XSLT).

BEMHTML-шаблон состоит из двух частей: предикат и тело шаблона. Предикат – это набор условий, при котороых выполняется шаблон, а тело – инструкции к выполнению.

===Предикаты

Предикат может состоять из одного или нескольких условий. Например:

block b-menu, elem item, elemMod state current, tag:

Запись через запятую означает, что шаблон применим только тогда, когда выполнятся все условия. Условия могут быть следующих типов:

 * выражающие совпадение со входным БЭМ-деревом
 * применяемая мода
 * произвольное условие

====Условия совпадения со входным БЭМ-деревом

При помощи этих условий можно выразить совпадение со входным БЭМ-деревом. Например, можно описать, что шаблон применим к конкретному блоку. Возможны следующие описания БЭМ-сущностей, к которым применим шаблон:

 * **предикат на блок**\\
   ##block b-menu##
 * **предикат на элемент блока**\\
   ##block b-menu, elem item##
 * **предикат на модификатор блока**\\
   ##block b-link, mod pseudo yes##
 * **предикат на модификатор элемента**\\
   block b-menu, elem item, elemMod state current

Именами и значениями БЭМ-сущностей в таких условиях могут быть также JS-выражения:

%%hl js
block 'b' + '-' + 'link'
%%

%%hl js
block b-menu, elem ['i', 't', 'e', 'm'].join('')
%%

====Моды

Для каждого блока может понадобиться несколько шаблонов: для тела, для атрибутов, для контента. Поэтому есть необходимость вводить понятие мод. Наличие разных мод позволяет написать несколько шаблонов для одной и той же БЭМ-сущности, каждый из которых продуцирует свою часть выходного HTML этой БЭМ-сущности.

Реализованы следующие моды:

 * **default**\\
   С обработки моды ##default## начинается работа любого bemhtml-шаблона. Если мода default явно не фигурирует в bemhtml-шаблоне, то работа происходит
      так, как описано в ядре (bemhtml-реализация элемента html блока i-bem): https://github.com/bem/bem-bl/blob/master/blocks-common/i-bem/__html/i-bem__html.bemhtml Там описано, в каких случаях и в каком порядке вызывать другие моды, относящиеся к контекстной БЭМ-сущности.
 * **bem**\\
   При установке в false позволяет не создавать у DOM-ноды данной БЭМ-сущности характерных CSS-классов в предметной области БЭМ.
 * **js**\\
   При установке в true говорит о том, что у блока есть клиентский JavaScript, значит, блок будет смиксован с блоком i-bem (появится дополнительный CSS-класс) и в его DOM-ноде появится атрибут onclick, хранящий параметры для клиентского js-компонента.

%%hl js
block b-link {
    ...
	js: true
	...
}
%%

 * **tag**\\
   Переопределяет HTML-тег БЭМ-сущности, который по умолчанию задан как div.

%%hl js
block b-icon {
    tag: 'img'
    ...
}
%%

 * **attrs**\\
   Расширяет множество атрибутов DOM-ноды БЭМ-сущности дополнительными значениями.

%%hl js
block b-icon {
    ...
    attrs: {

        return {};

    }
}
%%

 * **cls**\\
   Добавка к HTML-атрибуту class.
 * **mix**\\
   Определяет массив подмешиваемых БЭМ-сущностей. Используется для размещения на одном DOM-узле нескольких БЭМ-сущностей. Например, двух блоков, одного блока или элемента другого блока.\\
   Также нужен для подмешивания к существующей контекстной сущности модификаторов внутри bemhtml-шаблонов.
 * **content**\\
   Определяет содержание блока или элемента. Содержит bemjson, описывающий содержание или строку как частный случай простого bemjson.

%%hl js
block b-layout-table, elem gap {
    ...
    content: { elem:  'gap-i', tag:  'i',}
}
%%

====Произвольное условие

Произвольные условия учитывают совпадения с данными, не попадающими под предметную область БЭМ. Например,

%%hl js
block b-icon {
    ...
    attrs, this.ctx.url: {

        return { src: this.ctx.url };

    }
}
%%

Здесь ##this.ctx## — хеш с данными контекстной сущности из bemjson, в данном случае — блока b-icon.

Последнее из условий предиката отделено от тела шаблона двоеточием:

%%hl js
block b-icon, attrs, this.ctx.url: {
    Тело шаблона
}
%%

===Тело

После двоеточия bemhtml шаблон может содержать:

 * **boolean, строку или число**\\

%%hl js
block b-icon {
    tag: 'img'
    ...
}
%%

 * **bemjson**\\

%%hl js
block b-layout-table, elem gap {
    ...
    content: { elem:  'gap-i', tag:  'i' }
}
%%

 * **исполняемый JavaScript код (заключённый в фигурные скобки)**\\

%%hl js
block b-icon {
    ...
    attrs: {

        var ctx = this.ctx,
            a = { src: '//yandex.st/lego/_/La6qi18Z8LwgnZdsAr1qy1GwCwo.gif', alt: '' },
            props = ['src', 'alt', 'width', 'height'], p;

        while(p = props.shift()) ctx[p] && (a[p] = ctx[p]);

        return a;

    }
}
%%

===Контекст

Все шаблоны выполняются в каком-либо контексте. Контекст выражается ключевым словом this, доступным как в предикатах, так и в теле шаблона. В контексте есть набор полей:

 * **this.block** {String}\\
   Например, может быть использован в предикате для сравнения значения:

%%hl js
this.block === 'b-link'
%%

   Это идентично записи условия на языке БЭМ-сущностей

%%hl js
block b-link
%%

 * **this.elem** {String}\\
   Имя элемента
 * **this.mods** {Object}\\
   Модификаторы блока
 * **this.elemMods** {Object}
 * **this.ctx** {Object}\\
   Фрагмент входного дерева для текущего контекста. Входной JSON предоставляется "as is", безо всяких нормализаций и модификаций. Используется для получения доступа к данным, например, this.ctx.url в шаблоне блока b-link.
 * **this.isFirst** {Function}
 * **this.isLast** {Function}
 * **this.position** {Number}

===Синтаксис

Если у нескольких шаблонов часть предиката совпадает, их можно объединить, используя фигурные скобки. Например, так

%%hl js
block b-menu {
    elem item {
        Здесь всё про b-menu__item
    }
}
%%

можно описать элемент item блока в b-menu.

То же самое можно написать через запятую. Вот так:

%%hl js
block b-menu, elem item {
    Здесь всё про b-menu__item
}
%%

То есть, скобки — это syntax sugar над запятыми. Вложенность условий может быть сколь угодно большой.

====local

local — это блок кода языка bemhtml, по синтаксису подобный блокам while и for из JavaScript. Возможны такие варианты записи блока local:

 * **краткая запись**\\
%%hl js
local(expressions) code
%%

 * **полная запись**

%%hl js
local(expressions) {
    code
}
%%

local используется для временного изменения контекста и переменных, также для последующих операций с ними. В круглых скобках могут быть описаны только выражения присваивания, в фигурных — JavaScript-код, который выполняется с учётом заданных изменений. По выходу из блока local все
переменные и объекты (в том числе и this.ctx) приобретают свои прежние значения.
Более подробную информацию можно найти в документации xjst: https://github.com/veged/xjst/blob/master/doc/tech.ru.md
